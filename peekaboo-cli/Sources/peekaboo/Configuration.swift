import Foundation

/// Root configuration structure for Peekaboo settings.
///
/// This structure represents the complete configuration file format (JSONC) that can be
/// stored at `~/.config/peekaboo/config.json`. All properties are optional, allowing
/// partial configuration with fallback to environment variables or defaults.
struct Configuration: Codable {
    var aiProviders: AIProviderConfig?
    var defaults: DefaultsConfig?
    var logging: LoggingConfig?
    
    /// Configuration for AI vision providers.
    ///
    /// Defines which AI providers to use for image analysis, their API keys,
    /// and connection settings. Supports both cloud-based (OpenAI) and local (Ollama) providers.
    struct AIProviderConfig: Codable {
        var providers: String?
        var openaiApiKey: String?
        var ollamaBaseUrl: String?
    }
    
    /// Default settings for screenshot capture operations.
    ///
    /// These settings apply when no command-line arguments are provided,
    /// allowing users to customize their preferred capture behavior.
    struct DefaultsConfig: Codable {
        var savePath: String?
        var imageFormat: String?
        var captureMode: String?
        var captureFocus: String?
    }
    
    /// Logging configuration for debugging and troubleshooting.
    ///
    /// Controls the verbosity and location of log files generated by Peekaboo
    /// during operation.
    struct LoggingConfig: Codable {
        var level: String?
        var path: String?
    }
}

/// Manages configuration loading and precedence resolution.
///
/// `ConfigurationManager` implements a hierarchical configuration system with the following
/// precedence (highest to lowest):
/// 1. Command-line arguments
/// 2. Environment variables
/// 3. Configuration file (`~/.config/peekaboo/config.json`)
/// 4. Built-in defaults
///
/// The manager supports JSONC format (JSON with Comments) and environment variable
/// expansion using `${VAR_NAME}` syntax.
final class ConfigurationManager: @unchecked Sendable {
    static let shared = ConfigurationManager()
    
    /// Default configuration file path
    static var configPath: String {
        let configDir = NSString(string: "~/.config/peekaboo").expandingTildeInPath
        return "\(configDir)/config.json"
    }
    
    /// Loaded configuration
    private var configuration: Configuration?
    
    /// Load configuration from file
    func loadConfiguration() -> Configuration? {
        let configPath = Self.configPath
        
        guard FileManager.default.fileExists(atPath: configPath) else {
            return nil
        }
        
        do {
            let data = try Data(contentsOf: URL(fileURLWithPath: configPath))
            let jsonString = String(data: data, encoding: .utf8) ?? ""
            
            // Strip comments from JSONC
            let cleanedJSON = stripJSONComments(from: jsonString)
            
            // Expand environment variables
            let expandedJSON = expandEnvironmentVariables(in: cleanedJSON)
            
            // Parse JSON
            if let expandedData = expandedJSON.data(using: .utf8) {
                configuration = try JSONDecoder().decode(Configuration.self, from: expandedData)
                return configuration
            }
        } catch {
            print("Warning: Failed to load configuration from \(configPath): \(error)")
        }
        
        return nil
    }
    
    /// Strip comments from JSONC content
    internal func stripJSONComments(from json: String) -> String {
        var result = ""
        var inString = false
        var escapeNext = false
        var inSingleLineComment = false
        var inMultiLineComment = false
        
        let characters = Array(json)
        var i = 0
        
        while i < characters.count {
            let char = characters[i]
            let nextChar = i + 1 < characters.count ? characters[i + 1] : nil
            
            // Handle escape sequences
            if escapeNext {
                if !inSingleLineComment && !inMultiLineComment {
                    result.append(char)
                }
                escapeNext = false
                i += 1
                continue
            }
            
            // Check for escape character
            if char == "\\" && inString {
                escapeNext = true
                if !inSingleLineComment && !inMultiLineComment {
                    result.append(char)
                }
                i += 1
                continue
            }
            
            // Handle string boundaries
            if char == "\"" && !inSingleLineComment && !inMultiLineComment {
                inString.toggle()
                result.append(char)
                i += 1
                continue
            }
            
            // Inside string, keep everything
            if inString {
                result.append(char)
                i += 1
                continue
            }
            
            // Check for comment start
            if char == "/" && nextChar == "/" && !inMultiLineComment {
                inSingleLineComment = true
                i += 2
                continue
            }
            
            if char == "/" && nextChar == "*" && !inSingleLineComment {
                inMultiLineComment = true
                i += 2
                continue
            }
            
            // Check for comment end
            if char == "\n" && inSingleLineComment {
                inSingleLineComment = false
                result.append(char)
                i += 1
                continue
            }
            
            if char == "*" && nextChar == "/" && inMultiLineComment {
                inMultiLineComment = false
                i += 2
                continue
            }
            
            // Add character if not in comment
            if !inSingleLineComment && !inMultiLineComment {
                result.append(char)
            }
            
            i += 1
        }
        
        return result
    }
    
    /// Expand environment variables in the format ${VAR_NAME}
    internal func expandEnvironmentVariables(in text: String) -> String {
        let pattern = #"\$\{([A-Za-z_][A-Za-z0-9_]*)\}"#
        
        do {
            let regex = try NSRegularExpression(pattern: pattern, options: [])
            let range = NSRange(location: 0, length: text.utf16.count)
            
            var result = text
            
            // Find all matches in reverse order to preserve indices
            let matches = regex.matches(in: text, options: [], range: range).reversed()
            
            for match in matches {
                let varNameRange = match.range(at: 1)
                if let swiftRange = Range(varNameRange, in: text) {
                    let varName = String(text[swiftRange])
                    if let value = ProcessInfo.processInfo.environment[varName],
                       let fullMatch = Range(match.range, in: text) {
                        result.replaceSubrange(fullMatch, with: value)
                    }
                }
            }
            
            return result
        } catch {
            return text
        }
    }
    
    /// Get a configuration value with proper precedence: CLI args > env vars > config file > defaults
    func getValue<T>(
        cliValue: T?,
        envVar: String?,
        configValue: T?,
        defaultValue: T
    ) -> T {
        // CLI argument takes highest precedence
        if let cliValue = cliValue {
            return cliValue
        }
        
        // Environment variable takes second precedence
        if let envVar = envVar,
           let envValue = ProcessInfo.processInfo.environment[envVar] {
            // Try to convert string to the expected type
            if T.self == String.self {
                return envValue as! T
            } else if T.self == Bool.self {
                return (envValue.lowercased() == "true" || envValue == "1") as! T
            } else if T.self == Int.self {
                if let intValue = Int(envValue) {
                    return intValue as! T
                }
            } else if T.self == Double.self {
                if let doubleValue = Double(envValue) {
                    return doubleValue as! T
                }
            }
            // For other types, we can't convert from string, so fall through
        }
        
        // Config file value takes third precedence
        if let configValue = configValue {
            return configValue
        }
        
        // Default value as fallback
        return defaultValue
    }
    
    /// Get AI providers with proper precedence
    func getAIProviders(cliValue: String?) -> String {
        return getValue(
            cliValue: cliValue,
            envVar: "PEEKABOO_AI_PROVIDERS",
            configValue: configuration?.aiProviders?.providers,
            defaultValue: "ollama/llava:latest"
        )
    }
    
    /// Get OpenAI API key with proper precedence
    func getOpenAIAPIKey() -> String? {
        // Handle optional separately since getValue expects non-optional default
        if let envValue = ProcessInfo.processInfo.environment["OPENAI_API_KEY"] {
            return envValue
        }
        
        if let configValue = configuration?.aiProviders?.openaiApiKey {
            return configValue
        }
        
        return nil
    }
    
    /// Get Ollama base URL with proper precedence
    func getOllamaBaseURL() -> String {
        return getValue(
            cliValue: nil as String?,
            envVar: "PEEKABOO_OLLAMA_BASE_URL",
            configValue: configuration?.aiProviders?.ollamaBaseUrl,
            defaultValue: "http://localhost:11434"
        )
    }
    
    /// Get default save path with proper precedence
    func getDefaultSavePath(cliValue: String?) -> String {
        let path = getValue(
            cliValue: cliValue,
            envVar: "PEEKABOO_DEFAULT_SAVE_PATH",
            configValue: configuration?.defaults?.savePath,
            defaultValue: "~/Desktop"
        )
        return NSString(string: path).expandingTildeInPath
    }
    
    /// Get log level with proper precedence
    func getLogLevel() -> String {
        return getValue(
            cliValue: nil as String?,
            envVar: "PEEKABOO_LOG_LEVEL",
            configValue: configuration?.logging?.level,
            defaultValue: "info"
        )
    }
    
    /// Get log path with proper precedence
    func getLogPath() -> String {
        let path = getValue(
            cliValue: nil as String?,
            envVar: "PEEKABOO_LOG_PATH",
            configValue: configuration?.logging?.path,
            defaultValue: "~/.config/peekaboo/logs/peekaboo.log"
        )
        return NSString(string: path).expandingTildeInPath
    }
    
    /// Create default configuration file
    func createDefaultConfiguration() throws {
        let configPath = Self.configPath
        let configDir = URL(fileURLWithPath: configPath).deletingLastPathComponent()
        
        // Create directory if needed
        try FileManager.default.createDirectory(at: configDir, withIntermediateDirectories: true)
        
        let defaultConfig = """
        {
          // AI Provider Settings
          "aiProviders": {
            // Comma-separated list of AI providers in order of preference
            // Format: "provider/model,provider/model"
            // Supported providers: openai, ollama
            "providers": "openai/gpt-4o,ollama/llava:latest",
            
            // OpenAI API key - can use environment variable expansion
            // "openaiApiKey": "${OPENAI_API_KEY}",
            
            // Ollama server URL (if not using default)
            // "ollamaBaseUrl": "http://localhost:11434"
          },
          
          // Default Settings for Capture Operations
          "defaults": {
            // Default path for saving screenshots
            "savePath": "~/Desktop/Screenshots",
            
            // Default image format (png, jpg, jpeg)
            "imageFormat": "png",
            
            // Default capture mode (window, screen, area)
            "captureMode": "window",
            
            // Default focus behavior (auto, frontmost, none)
            "captureFocus": "auto"
          },
          
          // Logging Configuration
          "logging": {
            // Log level (trace, debug, info, warn, error, fatal)
            "level": "info",
            
            // Log file path
            "path": "~/.config/peekaboo/logs/peekaboo.log"
          }
        }
        """
        
        try defaultConfig.write(to: URL(fileURLWithPath: configPath), atomically: true, encoding: .utf8)
    }
}