import Foundation

/// Root configuration structure for Peekaboo settings.
///
/// This structure represents the complete configuration file format (JSONC) that can be
/// stored at `~/.config/peekaboo/config.json`. All properties are optional, allowing
/// partial configuration with fallback to environment variables or defaults.
struct Configuration: Codable {
    var aiProviders: AIProviderConfig?
    var defaults: DefaultsConfig?
    var logging: LoggingConfig?

    /// Configuration for AI vision providers.
    ///
    /// Defines which AI providers to use for image analysis, their API keys,
    /// and connection settings. Supports both cloud-based (OpenAI) and local (Ollama) providers.
    struct AIProviderConfig: Codable {
        var providers: String?
        var openaiApiKey: String?
        var ollamaBaseUrl: String?
    }

    /// Default settings for screenshot capture operations.
    ///
    /// These settings apply when no command-line arguments are provided,
    /// allowing users to customize their preferred capture behavior.
    struct DefaultsConfig: Codable {
        var savePath: String?
        var imageFormat: String?
        var captureMode: String?
        var captureFocus: String?
    }

    /// Logging configuration for debugging and troubleshooting.
    ///
    /// Controls the verbosity and location of log files generated by Peekaboo
    /// during operation.
    struct LoggingConfig: Codable {
        var level: String?
        var path: String?
    }
}

/// Manages configuration loading and precedence resolution.
///
/// `ConfigurationManager` implements a hierarchical configuration system with the following
/// precedence (highest to lowest):
/// 1. Command-line arguments
/// 2. Environment variables
/// 3. Configuration file (`~/.config/peekaboo/config.json`)
/// 4. Built-in defaults
///
/// The manager supports JSONC format (JSON with Comments) and environment variable
/// expansion using `${VAR_NAME}` syntax.
final class ConfigurationManager: @unchecked Sendable {
    static let shared = ConfigurationManager()

    /// Default configuration file path
    static var configPath: String {
        let configDir = NSString(string: "~/.config/peekaboo").expandingTildeInPath
        return "\(configDir)/config.json"
    }

    /// Loaded configuration
    private var configuration: Configuration?

    /// Load configuration from file
    func loadConfiguration() -> Configuration? {
        let configPath = Self.configPath

        guard FileManager.default.fileExists(atPath: configPath) else {
            return nil
        }

        do {
            let data = try Data(contentsOf: URL(fileURLWithPath: configPath))
            let jsonString = String(data: data, encoding: .utf8) ?? ""

            // Strip comments from JSONC
            let cleanedJSON = self.stripJSONComments(from: jsonString)

            // Expand environment variables
            let expandedJSON = self.expandEnvironmentVariables(in: cleanedJSON)

            // Parse JSON
            if let expandedData = expandedJSON.data(using: .utf8) {
                self.configuration = try JSONDecoder().decode(Configuration.self, from: expandedData)
                return self.configuration
            }
        } catch {
            print("Warning: Failed to load configuration from \(configPath): \(error)")
        }

        return nil
    }

    /// Strip comments from JSONC content
    func stripJSONComments(from json: String) -> String {
        var result = ""
        var inString = false
        var escapeNext = false
        var inSingleLineComment = false
        var inMultiLineComment = false

        let characters = Array(json)
        var i = 0

        while i < characters.count {
            let char = characters[i]
            let nextChar = i + 1 < characters.count ? characters[i + 1] : nil

            // Handle escape sequences
            if escapeNext {
                if !inSingleLineComment, !inMultiLineComment {
                    result.append(char)
                }
                escapeNext = false
                i += 1
                continue
            }

            // Check for escape character
            if char == "\\", inString {
                escapeNext = true
                if !inSingleLineComment, !inMultiLineComment {
                    result.append(char)
                }
                i += 1
                continue
            }

            // Handle string boundaries
            if char == "\"", !inSingleLineComment, !inMultiLineComment {
                inString.toggle()
                result.append(char)
                i += 1
                continue
            }

            // Inside string, keep everything
            if inString {
                result.append(char)
                i += 1
                continue
            }

            // Check for comment start
            if char == "/", nextChar == "/", !inMultiLineComment {
                inSingleLineComment = true
                i += 2
                continue
            }

            if char == "/", nextChar == "*", !inSingleLineComment {
                inMultiLineComment = true
                i += 2
                continue
            }

            // Check for comment end
            if char == "\n", inSingleLineComment {
                inSingleLineComment = false
                result.append(char)
                i += 1
                continue
            }

            if char == "*", nextChar == "/", inMultiLineComment {
                inMultiLineComment = false
                i += 2
                continue
            }

            // Add character if not in comment
            if !inSingleLineComment, !inMultiLineComment {
                result.append(char)
            }

            i += 1
        }

        return result
    }

    /// Expand environment variables in the format ${VAR_NAME}
    func expandEnvironmentVariables(in text: String) -> String {
        let pattern = #"\$\{([A-Za-z_][A-Za-z0-9_]*)\}"#

        do {
            let regex = try NSRegularExpression(pattern: pattern, options: [])
            let range = NSRange(location: 0, length: text.utf16.count)

            var result = text

            // Find all matches in reverse order to preserve indices
            let matches = regex.matches(in: text, options: [], range: range).reversed()

            for match in matches {
                let varNameRange = match.range(at: 1)
                if let swiftRange = Range(varNameRange, in: text) {
                    let varName = String(text[swiftRange])
                    if let value = ProcessInfo.processInfo.environment[varName],
                       let fullMatch = Range(match.range, in: text)
                    {
                        result.replaceSubrange(fullMatch, with: value)
                    }
                }
            }

            return result
        } catch {
            return text
        }
    }

    /// Get a configuration value with proper precedence: CLI args > env vars > config file > defaults
    func getValue<T>(
        cliValue: T?,
        envVar: String?,
        configValue: T?,
        defaultValue: T) -> T
    {
        // CLI argument takes highest precedence
        if let cliValue {
            return cliValue
        }

        // Environment variable takes second precedence
        if let envVar,
           let envValue = ProcessInfo.processInfo.environment[envVar]
        {
            // Try to convert string to the expected type
            if T.self == String.self {
                return envValue as! T
            } else if T.self == Bool.self {
                return (envValue.lowercased() == "true" || envValue == "1") as! T
            } else if T.self == Int.self {
                if let intValue = Int(envValue) {
                    return intValue as! T
                }
            } else if T.self == Double.self {
                if let doubleValue = Double(envValue) {
                    return doubleValue as! T
                }
            }
            // For other types, we can't convert from string, so fall through
        }

        // Config file value takes third precedence
        if let configValue {
            return configValue
        }

        // Default value as fallback
        return defaultValue
    }

    /// Get AI providers with proper precedence
    func getAIProviders(cliValue: String?) -> String {
        self.getValue(
            cliValue: cliValue,
            envVar: "PEEKABOO_AI_PROVIDERS",
            configValue: self.configuration?.aiProviders?.providers,
            defaultValue: "ollama/llava:latest")
    }

    /// Get OpenAI API key with proper precedence
    func getOpenAIAPIKey() -> String? {
        // Handle optional separately since getValue expects non-optional default
        if let envValue = ProcessInfo.processInfo.environment["OPENAI_API_KEY"] {
            return envValue
        }

        if let configValue = configuration?.aiProviders?.openaiApiKey {
            return configValue
        }

        return nil
    }

    /// Get Ollama base URL with proper precedence
    func getOllamaBaseURL() -> String {
        self.getValue(
            cliValue: nil as String?,
            envVar: "PEEKABOO_OLLAMA_BASE_URL",
            configValue: self.configuration?.aiProviders?.ollamaBaseUrl,
            defaultValue: "http://localhost:11434")
    }

    /// Get default save path with proper precedence
    func getDefaultSavePath(cliValue: String?) -> String {
        let path = self.getValue(
            cliValue: cliValue,
            envVar: "PEEKABOO_DEFAULT_SAVE_PATH",
            configValue: self.configuration?.defaults?.savePath,
            defaultValue: "~/Desktop")
        return NSString(string: path).expandingTildeInPath
    }

    /// Get log level with proper precedence
    func getLogLevel() -> String {
        self.getValue(
            cliValue: nil as String?,
            envVar: "PEEKABOO_LOG_LEVEL",
            configValue: self.configuration?.logging?.level,
            defaultValue: "info")
    }

    /// Get log path with proper precedence
    func getLogPath() -> String {
        let path = self.getValue(
            cliValue: nil as String?,
            envVar: "PEEKABOO_LOG_PATH",
            configValue: self.configuration?.logging?.path,
            defaultValue: "~/.config/peekaboo/logs/peekaboo.log")
        return NSString(string: path).expandingTildeInPath
    }

    /// Create default configuration file
    func createDefaultConfiguration() throws {
        let configPath = Self.configPath
        let configDir = URL(fileURLWithPath: configPath).deletingLastPathComponent()

        // Create directory if needed
        try FileManager.default.createDirectory(at: configDir, withIntermediateDirectories: true)

        let defaultConfig = """
        {
          // AI Provider Settings
          "aiProviders": {
            // Comma-separated list of AI providers in order of preference
            // Format: "provider/model,provider/model"
            // Supported providers: openai, ollama
            "providers": "openai/gpt-4o,ollama/llava:latest",

            // OpenAI API key - can use environment variable expansion
            // "openaiApiKey": "${OPENAI_API_KEY}",

            // Ollama server URL (if not using default)
            // "ollamaBaseUrl": "http://localhost:11434"
          },

          // Default Settings for Capture Operations
          "defaults": {
            // Default path for saving screenshots
            "savePath": "~/Desktop/Screenshots",

            // Default image format (png, jpg, jpeg)
            "imageFormat": "png",

            // Default capture mode (window, screen, area)
            "captureMode": "window",

            // Default focus behavior (auto, frontmost, none)
            "captureFocus": "auto"
          },

          // Logging Configuration
          "logging": {
            // Log level (trace, debug, info, warn, error, fatal)
            "level": "info",

            // Log file path
            "path": "~/.config/peekaboo/logs/peekaboo.log"
          }
        }
        """

        try defaultConfig.write(to: URL(fileURLWithPath: configPath), atomically: true, encoding: .utf8)
    }
}
