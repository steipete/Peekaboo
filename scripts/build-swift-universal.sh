#!/bin/bash
set -e # Exit immediately if a command exits with a non-zero status.

PROJECT_ROOT_REL=".." # Relative path to project root from peekaboo-cli
PROJECT_ROOT=$(cd "$(dirname "$0")/$PROJECT_ROOT_REL" && pwd)
SWIFT_PROJECT_PATH="$PROJECT_ROOT/peekaboo-cli"
FINAL_BINARY_NAME="peekaboo"
FINAL_BINARY_PATH="$PROJECT_ROOT/$FINAL_BINARY_NAME"

ARM64_BINARY_TEMP="$PROJECT_ROOT/${FINAL_BINARY_NAME}-arm64"
X86_64_BINARY_TEMP="$PROJECT_ROOT/${FINAL_BINARY_NAME}-x86_64"

# Swift compiler flags for size optimization
# -Osize: Optimize for binary size.
# -wmo: Whole Module Optimization, allows more aggressive optimizations.
# -Xlinker -dead_strip: Remove dead code at the linking stage.
SWIFT_OPTIMIZATION_FLAGS="-Xswiftc -Osize -Xswiftc -wmo -Xlinker -dead_strip -Xlinker -no_uuid"

echo "ğŸ§¹ Cleaning previous build artifacts..."
(cd "$SWIFT_PROJECT_PATH" && swift package reset) || echo "'swift package reset' encountered an issue, attempting rm -rf..."
rm -rf "$SWIFT_PROJECT_PATH/.build"
rm -f "$ARM64_BINARY_TEMP" "$X86_64_BINARY_TEMP" "$FINAL_BINARY_PATH.tmp"

echo "ğŸ“¦ Reading version from package.json..."
VERSION=$(node -p "require('$PROJECT_ROOT/package.json').version")
echo "Version: $VERSION"

echo "ğŸ’‰ Injecting version into Swift code..."
VERSION_SWIFT_PATH="$SWIFT_PROJECT_PATH/Sources/peekaboo/Version.swift"
cat > "$VERSION_SWIFT_PATH" << EOF
// This file is auto-generated by the build script. Do not edit manually.
enum Version {
    static let current = "$VERSION"
}
EOF

echo "ğŸ—ï¸ Building for arm64 (Apple Silicon)..."
(cd "$SWIFT_PROJECT_PATH" && swift build --arch arm64 -c release $SWIFT_OPTIMIZATION_FLAGS)
cp "$SWIFT_PROJECT_PATH/.build/arm64-apple-macosx/release/$FINAL_BINARY_NAME" "$ARM64_BINARY_TEMP"
echo "âœ… arm64 build complete: $ARM64_BINARY_TEMP"

echo "ğŸ—ï¸ Building for x86_64 (Intel)..."
(cd "$SWIFT_PROJECT_PATH" && swift build --arch x86_64 -c release $SWIFT_OPTIMIZATION_FLAGS)
cp "$SWIFT_PROJECT_PATH/.build/x86_64-apple-macosx/release/$FINAL_BINARY_NAME" "$X86_64_BINARY_TEMP"
echo "âœ… x86_64 build complete: $X86_64_BINARY_TEMP"

echo "ğŸ”— Creating universal binary..."
lipo -create -output "$FINAL_BINARY_PATH.tmp" "$ARM64_BINARY_TEMP" "$X86_64_BINARY_TEMP"

echo "ğŸ¤ Stripping symbols for further size reduction..."
# -S: Remove debugging symbols
# -x: Remove non-global symbols
strip -Sx "$FINAL_BINARY_PATH.tmp"

echo "ğŸ” Code signing the universal binary..."
if security find-identity -p codesigning -v | grep -q "Developer ID Application"; then
    # Sign with Developer ID if available
    SIGNING_IDENTITY=$(security find-identity -p codesigning -v | grep "Developer ID Application" | head -1 | awk '{print $2}')
    codesign --force --sign "$SIGNING_IDENTITY" \
        --options runtime \
        --identifier "com.steipete.peekaboo" \
        --timestamp \
        "$FINAL_BINARY_PATH.tmp"
    echo "âœ… Signed with Developer ID: $SIGNING_IDENTITY"
else
    # Fall back to ad-hoc signing for local builds
    codesign --force --sign - \
        --identifier "com.steipete.peekaboo" \
        "$FINAL_BINARY_PATH.tmp"
    echo "âš ï¸  Ad-hoc signed (no Developer ID found)"
fi

# Verify the signature and embedded info
echo "ğŸ” Verifying code signature..."
codesign -dv "$FINAL_BINARY_PATH.tmp" 2>&1 | grep -E "Identifier=|Signature"

# Replace the old binary with the new one
mv "$FINAL_BINARY_PATH.tmp" "$FINAL_BINARY_PATH"

echo "ğŸ—‘ï¸ Cleaning up temporary architecture-specific binaries..."
rm -f "$ARM64_BINARY_TEMP" "$X86_64_BINARY_TEMP"

echo "ğŸ” Verifying final universal binary..."
lipo -info "$FINAL_BINARY_PATH"
ls -lh "$FINAL_BINARY_PATH"

echo "ğŸ‰ Universal binary '$FINAL_BINARY_PATH' created and optimized successfully!" 