#!/bin/bash
# Smart CLI Wrapper for Peekaboo
# Automatically waits for Poltergeist rebuilds to complete before running

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
BINARY_PATH="$PROJECT_ROOT/peekaboo"
BUILD_LOCK="/tmp/peekaboo-cli-build.lock"
BUILD_STATUS="/tmp/peekaboo-cli-build-status.json"
RECOVERY_SIGNAL="/tmp/peekaboo-cli-build-recovery"
MAX_WAIT=300  # Maximum seconds to wait for build (5 minutes)
DEBUG="${PEEKABOO_WAIT_DEBUG:-false}"

# Poltergeist pgrun integration
PGRUN_PATH="/Users/steipete/Projects/poltergeist/dist/pgrun.js"

# Debug logging
debug_log() {
    if [ "$DEBUG" = "true" ]; then
        echo "[peekaboo-wait] $1" >&2
    fi
}

# Run pgrun health check and provide specific diagnostics
run_pgrun_health_check() {
    debug_log "Running pgrun health check..."
    
    # Check if pgrun is available
    if [ ! -f "$PGRUN_PATH" ]; then
        debug_log "pgrun not found at $PGRUN_PATH"
        return 1
    fi
    
    # Run pgrun with --verbose --no-wait to get immediate status
    local pgrun_output
    local pgrun_exit_code
    
    pgrun_output=$(node "$PGRUN_PATH" peekaboo-cli --verbose --no-wait --timeout 1000 2>&1)
    pgrun_exit_code=$?
    
    debug_log "pgrun exit code: $pgrun_exit_code"
    debug_log "pgrun output: $pgrun_output"
    
    # Parse pgrun output and provide specific guidance
    if [ $pgrun_exit_code -eq 0 ]; then
        # pgrun succeeded - binary should be fresh
        debug_log "pgrun health check passed"
        return 0
    else
        # pgrun failed - analyze the output for specific issues
        echo "🔍 Poltergeist Health Check Results:" >&2
        echo "" >&2
        
        if echo "$pgrun_output" | grep -q "No poltergeist.config.json found"; then
            echo "❌ Poltergeist configuration not found" >&2
            echo "   This usually means Poltergeist is not set up for this project." >&2
            echo "" >&2
            echo "🔧 TO FIX:" >&2
            echo "   1. Check if Poltergeist is running: npm run poltergeist:status" >&2
            echo "   2. Start Poltergeist: npm run poltergeist:haunt" >&2
            echo "" >&2
            
        elif echo "$pgrun_output" | grep -q "Target.*not found"; then
            echo "❌ Target 'peekaboo-cli' not found in Poltergeist config" >&2
            echo "   The Poltergeist configuration doesn't include the CLI target." >&2
            echo "" >&2
            echo "🔧 TO FIX:" >&2
            echo "   1. Check Poltergeist config: cat poltergeist.config.json" >&2
            echo "   2. Restart Poltergeist: npm run poltergeist:haunt" >&2
            echo "" >&2
            
        elif echo "$pgrun_output" | grep -q "Build in progress"; then
            echo "⏳ Build currently in progress" >&2
            echo "   Poltergeist is actively rebuilding the CLI." >&2
            echo "" >&2
            return 2  # Special code for "building"
            
        elif echo "$pgrun_output" | grep -q "Last build failed"; then
            echo "❌ Last Poltergeist build failed" >&2
            echo "" >&2
            echo "🔧 TO FIX:" >&2
            echo "   1. Check build logs: npm run poltergeist:logs" >&2
            echo "   2. Manual build: npm run build:swift" >&2
            echo "   3. Restart Poltergeist: npm run poltergeist:haunt" >&2
            echo "" >&2
            
        elif echo "$pgrun_output" | grep -q "Binary not found"; then
            echo "❌ CLI binary not found" >&2
            echo "   The expected binary doesn't exist at the configured path." >&2
            echo "" >&2
            echo "🔧 TO FIX:" >&2
            echo "   1. Manual build: npm run build:swift" >&2
            echo "   2. Check Poltergeist status: npm run poltergeist:status" >&2
            echo "" >&2
            
        else
            # Generic pgrun failure
            echo "❌ Poltergeist health check failed" >&2
            echo "" >&2
            echo "Raw pgrun output:" >&2
            echo "$pgrun_output" >&2
            echo "" >&2
            echo "🔧 TO FIX:" >&2
            echo "   1. Check Poltergeist status: npm run poltergeist:status" >&2
            echo "   2. Check build logs: npm run poltergeist:logs" >&2
            echo "   3. Manual build: npm run build:swift" >&2
            echo "" >&2
        fi
        
        return 1
    fi
}

# Function to check if binary is newer than all Swift sources
is_binary_fresh() {
    if [ ! -f "$BINARY_PATH" ]; then
        debug_log "Binary not found at $BINARY_PATH"
        return 1
    fi
    
    # Get binary modification time
    if [[ "$OSTYPE" == "darwin"* ]]; then
        BINARY_TIME=$(stat -f "%m" "$BINARY_PATH" 2>/dev/null)
    else
        BINARY_TIME=$(stat -c "%Y" "$BINARY_PATH" 2>/dev/null)
    fi
    
    debug_log "Binary modification time: $BINARY_TIME"
    
    # Find newest source file modification time
    NEWEST_SOURCE=0
    NEWEST_FILE=""
    while IFS= read -r -d '' file; do
        if [[ "$OSTYPE" == "darwin"* ]]; then
            FILE_TIME=$(stat -f "%m" "$file" 2>/dev/null)
        else
            FILE_TIME=$(stat -c "%Y" "$file" 2>/dev/null)
        fi
        if [ "$FILE_TIME" -gt "$NEWEST_SOURCE" ]; then
            NEWEST_SOURCE=$FILE_TIME
            NEWEST_FILE="$file"
        fi
    done < <(find "$PROJECT_ROOT/Core/PeekabooCore/Sources" "$PROJECT_ROOT/Core/AXorcist/Sources" "$PROJECT_ROOT/Apps/CLI/Sources" -name "*.swift" -type f -print0 2>/dev/null)
    
    debug_log "Newest source file: $NEWEST_FILE (time: $NEWEST_SOURCE)"
    
    # Binary is fresh if it's newer than all source files
    if [ "$BINARY_TIME" -ge "$NEWEST_SOURCE" ]; then
        debug_log "Binary is fresh"
        return 0
    else
        debug_log "Binary is stale (older than source files)"
        return 1
    fi
}

# Function to check if a build is running
is_build_running() {
    if [ -f "$BUILD_LOCK" ]; then
        PID=$(cat "$BUILD_LOCK" 2>/dev/null)
        if [ -n "$PID" ] && ps -p "$PID" > /dev/null 2>&1; then
            return 0
        else
            # Stale lock file
            debug_log "Removing stale build lock (PID $PID not running)"
            rm -f "$BUILD_LOCK"
        fi
    fi
    return 1
}


# Function to check build status from status file
check_build_status_file() {
    if [ ! -f "$BUILD_STATUS" ]; then
        debug_log "No build status file found"
        return 2  # Unknown status
    fi
    
    # Read status file
    local status=$(grep '"status"' "$BUILD_STATUS" 2>/dev/null | cut -d'"' -f4)
    local timestamp=$(grep '"timestamp"' "$BUILD_STATUS" 2>/dev/null | cut -d'"' -f4)
    local error_summary=$(grep '"error_summary"' "$BUILD_STATUS" 2>/dev/null | cut -d'"' -f4)
    
    # Check age of status
    if [ -n "$timestamp" ]; then
        # Convert ISO timestamp to epoch
        local status_epoch=$(date -u -j -f "%Y-%m-%dT%H:%M:%SZ" "$timestamp" "+%s" 2>/dev/null || date -u -d "$timestamp" "+%s" 2>/dev/null || echo "0")
        local current_epoch=$(date +%s)
        local age=$((current_epoch - status_epoch))
        
        # If status is older than 5 minutes, consider it stale
        if [ $age -gt 300 ]; then
            debug_log "Build status is stale (${age}s old)"
            return 2  # Unknown/stale status
        fi
    fi
    
    case "$status" in
        "building")
            debug_log "Build status: currently building"
            return 3  # Building
            ;;
        "success")
            debug_log "Build status: success"
            return 0  # Success
            ;;
        "failed")
            debug_log "Build status: failed - $error_summary"
            echo "❌ POLTERGEIST BUILD FAILED" >&2
            echo "" >&2
            if [ -n "$error_summary" ]; then
                echo "Error: $error_summary" >&2
            else
                echo "Build failed. Check 'npm run poltergeist:logs' for details." >&2
            fi
            echo "" >&2
            echo "🔧 TO FIX: Run 'npm run build:swift' to see and fix the compilation errors." >&2
            echo "   After fixing, the wrapper will automatically use the new binary." >&2
            echo "" >&2
            return 1  # Failed
            ;;
        *)
            debug_log "Build status: unknown ($status)"
            return 2  # Unknown
            ;;
    esac
}

# Main logic
debug_log "Starting peekaboo-wait wrapper"
debug_log "Binary path: $BINARY_PATH"
debug_log "Build lock: $BUILD_LOCK"

# First, check if binary is already fresh
if is_binary_fresh; then
    debug_log "Binary is fresh, executing immediately"
    exec "$BINARY_PATH" "$@"
fi

# Binary is stale, check build status first
debug_log "Binary is stale, checking build status"

# Check if there's a recent build failure
check_build_status_file
status_result=$?

if [ $status_result -eq 1 ]; then
    # Build failed - exit with special code to trigger manual rebuild
    exit 42  # Special exit code for build failure
fi

# Check for ongoing build
if ! is_build_running; then
    # No build running, but binary is stale
    if [ $status_result -eq 0 ]; then
        # Status says success but binary is stale - might be a race condition
        debug_log "Status shows success but binary is stale, proceeding anyway"
    else
        # Unknown status or stale - run pgrun health check for detailed diagnostics
        debug_log "Binary is stale and no build running, running pgrun health check"
        
        run_pgrun_health_check
        pgrun_result=$?
        
        if [ $pgrun_result -eq 0 ]; then
            # pgrun says everything is fine - proceed
            debug_log "pgrun health check passed, proceeding with execution"
        elif [ $pgrun_result -eq 2 ]; then
            # pgrun detected build in progress - wait for it
            debug_log "pgrun detected build in progress, will wait"
        else
            # pgrun detected issues - detailed diagnostics already printed
            debug_log "pgrun health check failed, diagnostics printed"
            echo "💡 The wrapper detected issues with the build system." >&2
            echo "   Please follow the steps above to resolve the problem." >&2
            echo "" >&2
            echo "   If issues persist, try a manual build: npm run build:swift" >&2
            exit 1
        fi
        
        # Give Poltergeist a moment to detect the stale binary
        sleep 2
    fi
fi

wait_count=0
while is_build_running && [ $wait_count -lt $MAX_WAIT ]; do
    if [ $wait_count -eq 0 ]; then
        echo "🔨 Poltergeist is rebuilding the Swift CLI..." >&2
    fi
    sleep 1
    ((wait_count++))
    
    # Show progress with more helpful messages
    if [ $((wait_count % 10)) -eq 0 ] && [ $wait_count -gt 0 ]; then
        remaining=$((MAX_WAIT - wait_count))
        echo "   Still building... (${wait_count}s elapsed, max ${remaining}s remaining)" >&2
        
    fi
done

if [ $wait_count -ge $MAX_WAIT ]; then
    echo "⚠️  Build timeout reached (${MAX_WAIT}s / 5 minutes)." >&2
    echo "   Check build status with: npm run poltergeist:status" >&2
fi



# Final checks after waiting
debug_log "Performing final checks after wait"

# Check build status file again
check_build_status_file
final_status=$?

if [ $final_status -eq 1 ]; then
    # Build failed - exit with special code
    exit 42  # Special exit code for build failure
fi

# Final freshness check
if is_binary_fresh; then
    debug_log "Binary is now fresh after waiting"
else
    debug_log "Binary might still be stale, but proceeding"
    # If the binary exists but is stale, Poltergeist should pick it up
    # We'll run it anyway to avoid blocking
fi

# Execute the binary if it exists
if [ -f "$BINARY_PATH" ]; then
    debug_log "Executing: $BINARY_PATH $*"
    exec "$BINARY_PATH" "$@"
else
    echo "❌ Binary not found at: $BINARY_PATH" >&2
    echo "   This usually means the build failed." >&2
    echo "   Check: npm run poltergeist:logs" >&2
    exit 1
fi